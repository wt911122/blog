{"data":{"markdownRemark":{"html":"<h1>Vue 原理剖析</h1>\n<h3>1、模拟双向绑定</h3>\n<pre><code class=\"language-javascript\">class Dep {\n    constructor(){\n        this.subscibes = [];\n    }\n    depend(){\n        this.subscibes.push(watcher.activeupdate)\n    }\n    notify(){\n        this.subscibes.forEach((c) => c());\n    }\n}\nfunction observe(ob){\n    const dep = new Dep();\n    Object.keys(ob).forEach(k => {\n        let value = ob[k];\n        Object.defineProperty(ob, k, {\n            get(){\n                if(watcher.activeupdate){\n                    dep.depend();\n                }\n                return value\n            },\n            set(val){\n                console.log('setob');\n                value = val\n                dep.notify()\n            }\n        })\n    })\n}\n\n\n\nfunction watcher(update){\n    const watch = function(){\n        watcher.activeupdate = update;\n        update();\n        watcher.activeupdate = null;\n    }\n\n    watch();\n}\nwatcher.activeupdate = null\n</code></pre>\n<pre><code class=\"language-html\">&#x3C;!doctype html>\n&#x3C;html>\n&#x3C;head>\n    &#x3C;title>vue mode&#x3C;/title>\n    &#x3C;script src=\"index.js\">&#x3C;/script>\n&#x3C;/head>\n&#x3C;body>\n&#x3C;div id=\"test\">&#x3C;/div>\n&#x3C;input id=\"input\" />\n&#x3C;script>\nconst inputEl = document.getElementById('input');\nconst testEl = document.getElementById('test');\n\nconst data = {\n    content: 'xxx',\n}\nobserve(data)\n\nwatcher(() => {\n    testEl.innerText = data.content;\n    inputEl.value = data.content;\n})\n\ndata.content = 'sssssss'\ninputEl.oninput = function(){\n    data.content = this.value;\n}\n&#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<h3>2、双向绑定与页面刷新</h3>\n<p>Vue在初始化的时候，向Vue对象注入了多个mixin，其中包括了lifecycle mixin，这个mixin在视图数据绑定上起了至关重要的作用，因为当你写入<code>Vue.$mount(…)</code>方法时，魔法就开始发生了，这个方法是从lifecycle mixin中注入进来的，其作用在于向vue component对象中写入一个<code>_watcher</code>，这个<code>_watcher</code>相当于上面的watcher方法，其只负责在监视到数据变化的时候调用如下方法：</p>\n<pre><code class=\"language-javascript\">    updateComponent = () => {\n      vm._update(vm._render(), hydrating)\n    }\n</code></pre>\n<p><code>vm._render()</code>生成了一个Vnode，其中老的Vnode已经在上一次存入了vm对象中，所以通过_update方法来集中访问这个老的Vnode</p>\n<pre><code class=\"language-javascript\">const prevVnode = vm._vnode\n...\nif (!prevVnode) {\n    // initial render\n    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n} else {\n    // updates\n    vm.$el = vm.__patch__(prevVnode, vnode)\n}\n</code></pre>\n<p><code>__patch__</code>方法就是经常被与react的diff算法比较的存在。</p>","frontmatter":{"date":"February 23, 2018","path":"/vue-pricipal","title":"Vue 原理剖析"}}},"pageContext":{}}